-- Hammerspoon Controller Mapper (Refactored)
-- Receives DS4 data from Python and maps it to key presses with improved efficiency and responsiveness.

local json = require("hs.json")
local eventtap = require("hs.eventtap")
local keycodes = require("hs.keycodes").map

local controller = {}

-- ##################################################################
-- MAPPINGS GENERATED BY DS4 MAPPING UI (This part remains the same)
-- ##################################################################
controller.mappings = {
    ["Default"] = {
        buttons = {
            touchpad = {modifiers={}, key="p"},
            l3 = {modifiers={}, key="left"},
            square = {modifiers={}, key="left"},
            r3 = {modifiers={}, key="d"},
            ps = {modifiers={}, key="right"},
            circle = {modifiers={}, key="right"},
            cross = {modifiers={}, key="b"}
        },
        dpad = {
            down = {modifiers={}, key="down"},
            right = {modifiers={}, key="right"},
            left = {modifiers={}, key="left"},
            up = {modifiers={}, key="up"}
        }
    },
    ["Mail"] = {
        buttons = {
            square = {modifiers={"cmd"}, key="backspace"}
        },
        dpad = {
            down = {modifiers={}, key="right"},
            right = {modifiers={}, key="left"},
            left = {modifiers={}, key="up"},
            up = {modifiers={}, key="down"}
        }
    },
    ["Adobe Lightroom Classic"] = {
        buttons = {
            square = {modifiers={}, key="left"},
            circle = {modifiers={}, key="right"},
            cross = {modifiers={}, key="left"},
            triangle = {modifiers={}, key="right"}
        },
        dpad = {
        }
    }
}
-- ##################################################################


-- State tracking now stores the entire previous data packet for the active profile
local previousState = {}

--- Translates user-friendly key names to Hammerspoon keycodes.
local function translateKey(key)
    local keyTranslations = {
        ["backspace"] = "delete",
        ["enter"] = "return",
        ["esc"] = "escape"
        -- Add more as needed
    }
    key = key:lower()
    return keyTranslations[key] or key
end

--- Posts a key event to the system.
-- @param mapping The mapping table, e.g., {modifiers={...}, key="..."}
local function postKeyEvent(mapping)
    if not mapping or not mapping.key then return end

    local mods = mapping.modifiers or {}
    local key = translateKey(mapping.key)
    
    -- Build a description for logging
    local keydesc = (next(mods) and table.concat(mods, "-") .. "-" or "") .. key
    print("ðŸŽ® Controller -> Key: " .. keydesc)
    
    hs.eventtap.keyStroke(mods, key)
end

--- Processes changes in button states.
-- @param newButtons The table of current button states.
-- @param oldButtons The table of previous button states.
-- @param buttonMappings The mappings for the current profile's buttons.
local function handleButtonEvents(newButtons, oldButtons, buttonMappings)
    for button, isPressed in pairs(newButtons) do
        -- Rising-edge detection: fire on press (false -> true)
        if isPressed and not oldButtons[button] then
            postKeyEvent(buttonMappings[button])
        end
    end
end

--- Processes changes in the D-Pad state.
-- @param newDpad The current D-Pad direction string.
-- @param oldDpad The previous D-Pad direction string.
-- @param dpadMappings The mappings for the current profile's D-pad.
local function handleDpadEvents(newDpad, oldDpad, dpadMappings)
    -- Fire on initial press (e.g., "none" -> "up")
    if newDpad ~= "none" and newDpad ~= oldDpad then
        postKeyEvent(dpadMappings[newDpad])
    end
end


--- The main callback function to process incoming controller data from Python.
-- @param data The raw JSON string from the UDP socket.
function controller.processData(data)
    local status, decoded = pcall(json.decode, data)
    if not status or not decoded then
        print("Error decoding JSON: " .. tostring(data))
        return
    end

    -- 1. Select Profile
    local activeApp = hs.application.frontmostApplication()
    local appName = activeApp and activeApp:name() or "Default"
    local profile = controller.mappings[appName] or controller.mappings["Default"]
    
    if not profile then return end -- No mappings to process

    -- 2. Get Previous State
    -- If this is the first time for this profile, use an empty table.
    local oldState = previousState[appName] or {buttons={}, dpad="none"}

    -- 3. Process Events
    if profile.buttons then
        handleButtonEvents(decoded.buttons, oldState.buttons, profile.buttons)
    end
    
    if profile.dpad then
        handleDpadEvents(decoded.dpad, oldState.dpad, profile.dpad)
    end
    
    -- 4. Update State
    -- Store the current state for the next comparison.
    previousState[appName] = decoded
end


-- ## Socket Control ## --

local udpSocket = nil
local UDP_PORT = 12345 -- Must match the port in your Python script

function controller:start()
    if udpSocket then
        print("Controller mapper already running.")
        return
    end

    print("Starting controller mapper...")
    udpSocket = hs.socket.udp.new()
    udpSocket:setCallback(controller.processData)

    if udpSocket:listen(UDP_PORT) then
        udpSocket:receive()
        hs.notify.new({title="Controller Active", informativeText="DS4 mapping is ON."}):send()
    else
        hs.notify.new({title="Controller Error", informativeText="Could not listen on port " .. UDP_PORT}):send()
        udpSocket = nil
    end
end

function controller:stop()
    if udpSocket then
        print("Stopping controller mapper...")
        udpSocket:close()
        udpSocket = nil
        hs.notify.new({title="Controller Inactive", informativeText="DS4 mapping is OFF."}):send()
    else
        print("Controller mapper is not running.")
    end
end

-- Start automatically
controller:start()

return controller