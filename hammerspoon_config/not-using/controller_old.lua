-- Hammerspoon Controller Mapper
-- Receives DS4 data from Python script via UDP and maps it to key presses.

local json = require("hs.json")
local eventtap = require("hs.eventtap")

local controller = {}

-- ##################################################################
-- MAPPINGS GENERATED BY DS4 MAPPING UI
-- ##################################################################
controller.mappings = {
    ["Default"] = {
        buttons = {
            touchpad = {modifiers={}, key="p"},
            l3 = {modifiers={}, key="left"},
            square = {modifiers={}, key="left"},
            r3 = {modifiers={}, key="d"},
            ps = {modifiers={}, key="right"},
            circle = {modifiers={}, key="right"},
            cross = {modifiers={}, key="b"}
        },
        dpad = {
            down = {modifiers={}, key="down"},
            right = {modifiers={}, key="right"},
            left = {modifiers={}, key="left"},
            up = {modifiers={}, key="up"}
        }
    },
    ["Mail"] = {
        buttons = {
            square = {modifiers={"cmd"}, key="backspace"}
        },
        dpad = {
            down = {modifiers={}, key="right"},
            right = {modifiers={}, key="left"},
            left = {modifiers={}, key="up"},
            up = {modifiers={}, key="down"}
        }
    },
    ["Adobe Lightroom Classic"] = {
        buttons = {
            square = {modifiers={}, key="left"},
            circle = {modifiers={}, key="right"},
            cross = {modifiers={}, key="left"},
            triangle = {modifiers={}, key="right"}
        },
        dpad = {
        }
    }
}

-- ##################################################################

local keycodes = require("hs.keycodes").map

-- Key translation table for user-friendly names
local keyTranslations = {
    ["backspace"] = "delete",
    ["enter"] = "return",
    ["esc"] = "escape"
    -- Add more as needed
}

-- Helper function to translate keys
local function translateKey(key)
    key = key:lower()
    if keycodes[key] then
        return key
    elseif keyTranslations[key] then
        return keyTranslations[key]
    else
        return key
    end
end

-- State tracking to prevent continuous key presses (profile-specific)
local previousState = {
    buttons = {},  -- Will be profile-specific: buttons[profile][button]
    dpad = {},     -- Will be profile-specific: dpad[profile]
    sticks = { left = {}, right = {} }
}

-- UDP socket to listen for data from Python
local udpSocket = nil
local UDP_PORT = 12345 -- Must match the port in your Python script

-- ## Core Mapping Logic ## --

function controller.processData(data)
    local status, decoded = pcall(json.decode, data)
    if not status then
        return
    end

    -- Get the active application name for profile selection
    local activeApp = hs.application.frontmostApplication()
    local appName = activeApp and activeApp:name() or "Default"
    
    -- Select the appropriate profile
    local profile = controller.mappings[appName] or controller.mappings["Default"] or {buttons = {}, dpad = {}}
    
    -- Initialize profile-specific state tracking
    if not previousState.buttons[appName] then
        previousState.buttons[appName] = {}
    end
    if not previousState.dpad[appName] then
        previousState.dpad[appName] = {}
    end
    
    -- TRUE EVENT-BASED PROCESSING
    -- Only process if there's an actual event (button press, d-pad change, stick movement)
    local hasEvent = false
    local events = {}

    -- 1. Check for button events (only process if buttons changed)
    for button, mapping in pairs(profile.buttons) do
        local isPressed = decoded.buttons[button]
        local wasPressed = previousState.buttons[appName][button] or false

        -- Rising edge detection (false -> true transition)
        if isPressed and not wasPressed then
            hasEvent = true
            table.insert(events, {type = "button", button = button, mapping = mapping})
        end
        previousState.buttons[appName][button] = isPressed
    end

    -- 2. Check for D-Pad events (only process if d-pad changed)
    local currentDpad = decoded.dpad
    local previousDpad = previousState.dpad[appName].current or "none"

    if currentDpad ~= previousDpad then
        hasEvent = true
        local dpadToDirection = {
            ["up"] = "up", ["down"] = "down", ["left"] = "left", ["right"] = "right",
            ["ne"] = "ne", ["se"] = "se", ["sw"] = "sw", ["nw"] = "nw"
        }
        -- Trigger on button RELEASE (when going from a direction back to "none")
        if currentDpad == "none" and previousDpad ~= "none" then
            local direction = dpadToDirection[previousDpad]
            if direction and profile.dpad[direction] then
                table.insert(events, {type = "dpad", direction = direction, mapping = profile.dpad[direction]})
            end
        end
        previousState.dpad[appName].current = currentDpad
    end

    -- 4. Process all events at once (only if there are events)
    if hasEvent then
        for _, event in ipairs(events) do
            local keydesc = ""
            local modifiers = {}
            local key = nil

            -- Support new mapping format: {modifiers=..., key=...}
            if event.mapping and type(event.mapping) == "table" and event.mapping.key then
                modifiers = event.mapping.modifiers or {}
                key = translateKey(event.mapping.key)  -- Translate the key
                keydesc = (next(modifiers) and table.concat(modifiers, "-") .. "-" or "") .. key
            else
                key = translateKey(event.mapping or event.key)  -- Translate the key
                keydesc = tostring(key)
            end

            if event.type == "button" then
                print("ðŸŽ® Button pressed: " .. event.button .. " -> Key: " .. keydesc)
            elseif event.type == "dpad" then
                print("ðŸŽ® D-pad pressed: " .. event.direction .. " -> Key: " .. keydesc)
            end

            -- Send the key event
            hs.eventtap.keyStroke(modifiers, key)
        end
    end
end


-- ## Socket Control ## --

function controller:start()
    if udpSocket then
        print("Controller mapper already running.")
        return
    end

    print("Starting controller mapper...")
    udpSocket = hs.socket.udp.new()
    udpSocket:setCallback(controller.processData)

    local success = udpSocket:listen(UDP_PORT)
    if success then
        udpSocket:receive()
        hs.notify.new({title="Controller Active", informativeText="DS4 mapping is ON."}):send()
    else
        hs.notify.new({title="Controller Error", informativeText="Could not listen on port " .. UDP_PORT}):send()
        udpSocket = nil
    end
end

function controller:stop()
    if udpSocket then
        print("Stopping controller mapper...")
        udpSocket:close()
        udpSocket = nil
        hs.notify.new({title="Controller Inactive", informativeText="DS4 mapping is OFF."}):send()
    else
        print("Controller mapper is not running.")
    end
end

-- Start automatically
controller:start()

return controller
